function [x,output,exitFlag] = logInteriorPoint(W,c,Aineq,bineq,v0,opts)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

exitFlag =  1; %  exitFlag = 0 indicates max  iter exceeded

% Get size variable
m = size(Aineq,1);
n = size(Aineq,2);

% Set options
if isfield(opts,'mu_f')
    mu_f = opts.mu_f;
else
    mu_f = 1e-8;
end
if isfield(opts,'mu_0')
    mu_0 = opts.mu_0;
else
    mu_0 = 1e8;
end
if isfield(opts,'maxIter')
    maxIter = opts.maxIter;
else
    maxIter = 150;
end
if isfield(opts,'printFlag')
    printFlag = opts.printFlag;
else
    printFlag = 0;
end
if isfield(opts,'maxCGIter')
    maxCGIter = opts.maxCGIter;
else
    maxCGIter = 1000;
end
if isfield(opts,'CGTol')
    CGTol = opts.CGTol;
else
    CGTol = 1e-8;
end

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Pack
const.W = W;
const.c = c;
const.A = Aineq;
const.b = bineq;
A = Aineq;

% Initialize
mu = mu_0;
CGIters = zeros(maxIter,1);
muVec = zeros(maxIter,1);
numIter = 1;

%%  FIRST INITIALIZATION PROCEDURE 
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
tic;
v = v0;
x = zeros(n,1);

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)
% Sample point 1
mu1 = mu;
k1 = 1/sqrt(mu1);
[x1Hat,d1Hat,cg1] = solveNewtonStep(mu1,v,const,maxCGIter,CGTol,x);


% Sample point 2
mu2 = 0.5*mu;
k2 = 1/sqrt(mu2);
[x2Hat,d2Hat,cg2] = solveNewtonStep(mu2,v,const,maxCGIter,CGTol,x1Hat);
CGIters(numIter) = cg1 + cg2;

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'inf'))
    end
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
else
    mu = mu_0; % under the update at the end
    d = 1.1*ones(m,1);
    v = zeros(m,1);
    startFlag = 0;
end
muVec(numIter) = mu;
numIter = numIter + 1;

%% CENTERING PROCEDURE

% If we have a pair (mu,d) with d > 1 and we iterate the Newton
% algorithm until we obtain convergence. If we found a muStar from our
% initialization, this loop will be skipped.
if  startFlag < 1
    while norm(d,'inf') > 1
        % Solve for d
        if numIter >= maxIter % We want at least aa feasible soluton
            exitFlag =  0;
            break
        end
        [x,d,cg1] = solveNewtonStep(mu,v,const,maxCGIter,CGTol,x);

        % Store variables
        CGIters(numIter) = cg1;
        muVec(numIter) = mu;

        % Update v
        alpha = min(1, 1/(norm(d,'inf')^2));
        v = v + alpha*d;
        numIter = numIter + 1;
        
        % Print statement
        if printFlag
            fprintf('mu = %0.2e, d = %0.4f (Initial Stage) \n',mu,norm(d,'inf'))
        end
    end
end

%%  MAIN NEWTON ITERATION LOOP 

% Then, we finally run the main loop which selects uStar
if startFlag < 1
    x1Hat = x;
end
while mu > mu_f || norm(d,'inf') > 1
    if numIter >= maxIter % We want at least aa feasible soluton
        exitFlag  =  0;
        break
    end
    
    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)

    % Sample point 1
    mu1 = mu;
    k1 = 1/sqrt(mu1);
    [x1Hat,d1Hat,cg1] = solveNewtonStep(mu1,v,const,maxCGIter,CGTol,x1Hat);
    
    % Sample point 2
    mu2 = 0.5*mu;
    k2 = 1/sqrt(mu2);
    [x2Hat,d2Hat,cg2] = solveNewtonStep(mu2,v,const,maxCGIter,CGTol,x2Hat);

    % Obtain affine representation of d = d0 + k*d1
    c0 = -k2/(k1-k2);
    c1 = 1/(k1-k2);
    d0 = c0*d1Hat + (1-c0)*d2Hat;
    d1 = c1*(d1Hat - d2Hat);
    
    % Solve for muStar using bisection
    [mu,d] = muStarSolve(d0,d1,1,mu_f);
    
    % Make sure that muStar is finite and catch it if not
    if isinf(mu)
        mu = mu1;
        d = d1Hat;
    end
    
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f \n',mu,norm(d,'inf'))
    end
    
    % Update x, v, d
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;

    % Store variables
    CGIters(numIter) = cg1+cg2;
    muVec(numIter) = mu;
    numIter = numIter + 1;
end

% We run the Newton system one more time to get the primal variable x
% x = solveNewtonStep(mu,v,const);
[x,d,cg1] = solveNewtonStep(mu,v,const,maxCGIter,CGTol,x1Hat);
CGIters(numIter) = cg1;
muVec(numIter) = mu;
output.lambda = sqrt(mu)*exp(v);
output.s = sqrt(mu)*exp(-v);
output.v = v;
comp_time = toc;

% Set outher outputs
output.mu = mu;
output.startFlag = startFlag;
output.numIter = numIter;
output.muStar = muStar;
output.exitFlag = exitFlag;
output.comp_time = comp_time;
output.CGIters = CGIters(1:numIter);
output.muVec = muVec(1:numIter);
end

function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end



function [x,d,numIter,res] = solveNewtonStep(mu,v,const,maxIter,tol,x0)
W = const.W;
% invW = const.invW;
c = const.c;
A = const.A;
b = const.b;
m = size(A,1);

% Define the RHS vector b
Q = diag(exp(2*v));
M = A'*Q*A + W;
f = 2*sqrt(mu)*A'*exp(v) - (c + A'*Q*b);

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.

% Run the first iteration of CG and iniialize iteration variables
x = x0;
r = f - M*x0;

% Calculate iteration constants
z = r;
p = z;
w = M*p;
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
numIter = 1;

% Iterate...
while numIter  < maxIter && res > tol 
    zPrev = z;
    z = r;
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = M*p;
    alpha = r'*z/(p'*w);
    
    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);

    % i++
    numIter = numIter + 1;
end
d = ones(m,1) - 1/sqrt(mu)*exp(v).*(A*x + b);
end







