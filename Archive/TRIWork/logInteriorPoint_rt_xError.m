function [x,xError_vec,execTime,numIter] = logInteriorPoint_rt(W,c,A,bineq,mu_f,mu_0,v0,maxIter,xStar,xTol)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

% Get size variables
m = size(A,1);
n = size(A,2);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
A = - A;

% Pack
invW = inv(W);
const.W = W;
const.c = c;
const.A = A;
const.b = bineq;

% Max amount of bisection iterations
numIter = 0; % number of newton iterations performed

% --------------------- FIRST NEWTON ITERATION ---------------------
% If we provide a warm-start
tic
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
v = v0;

% Construct Q matrix
Qvec = exp(2*v);
Q = diag(Qvec);
G = (A'*Q*A + W);
% dG = decomposition(G,'lu');
% dG = decomposition(1/2*(G+G'),'chol');
dG = chol(G);

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)
% Sample point 1
mu = mu_0;
mu1 = mu;
k1 = 1/sqrt(mu1);
[~,d1Hat] = solveNewtonStep_decomp(mu1,v,const,dG);

% Sample point 2
mu2 = 0.1*mu;
k2 = 1/sqrt(mu2);
[~,d2Hat] = solveNewtonStep_decomp(mu2,v,const,dG);

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;

    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
    numIter = numIter + 1;
else % Otherwise, truly give  up and cold start
    mu = mu_0; % under the update at the end
    d = Inf*dStar;
    v = zeros(size(A,1),1);
    startFlag = 0;
end
x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
xError_vec = zeros(maxIter,1);
xError = norm(x - xStar);
xError_vec(1) = xError;

% If we have a pair (mu,d) with d > 1 and we iterate the Newton
% algorithm until we obtain convergence. If we found a muStar from our
% initialization, this loop will be skipped.
if  startFlag < 1
    while norm(d,'inf') > 1
        % Solve for d
        if numIter >= maxIter % We want at least aa feasible soluton
            exitFlag =  0;
            break
        end
        [x,d] = solveNewtonStep(mu,v,const);
        xError = norm(x - xStar);
        xError_vec(numIter+1) = xError;
        
        % Update v
        alpha = min(1, 1/(norm(d,'inf')^2));
        v = v + alpha*d;
        numIter = numIter + 1;
    end
end

% --------------------- MAIN NEWTON ITERATION LOOP ---------------------

% Then, we finally run the main loop which selects uStar
% Construct Q matrix
dNorm = 1;
while (xError > xTol || dNorm > 1) && numIter < maxIter
    
    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)
    Q = diag(exp(2*v));
    G = (A'*Q*A + W);
%     dG = decomposition(1/2*(G+G'),'chol');
    dG = chol(G);

    % Sample point 1
    mu1 = mu;
    k1 = 1/sqrt(mu1);
    [~,d1Hat] = solveNewtonStep_decomp(mu1,v,const,dG);
    
    % Sample point 2
    mu2 = 0.1*mu;
    k2 = 1/sqrt(mu2);
    [~,d2Hat] = solveNewtonStep_decomp(mu2,v,const,dG);
    
    % Obtain affine representation of d = d0 + k*d1
    c0 = -k2/(k1-k2);
    c1 = 1/(k1-k2);
    d0 = c0*d1Hat + (1-c0)*d2Hat;
    d1 = c1*(d1Hat - d2Hat);
    
    % Solve for muStar using bisection
    [mu,d] = muStarSolve(d0,d1,1,mu_f);
    
    % Get xError
    x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
    xError = norm(x - xStar);
    xError_vec(numIter+1) = xError;
    
    % Make sure that muStar is finite and catch it if not
    if isinf(mu)
        mu = mu1;
        d = d1Hat;
    end
    
    % Update x, v, d
    dNorm = norm(d,'inf');
    alpha = min(1, 1/(dNorm^2));
    v = v + alpha*d;
    numIter = numIter + 1;
end
execTime = toc;
xError_vec = xError_vec(1:numIter);
end

function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end


function [x,d] = solveNewtonStep(mu,v,const)
W = const.W;
c = const.c;
A = const.A;
b = const.b;
m = size(A,1);

% Construct Q matrix
Qvec = exp(2*v);
Q = diag(Qvec);

% Solve for x
x = (A'*Q*A + W)\(2*sqrt(mu)*A'*exp(v) - (c + A'*Q*b));

% Solve for d
d = ones(m,1) - (1/sqrt(mu))*exp(v).*(A*x + b);

end


function [x,d] = solveNewtonStep_decomp(mu,v,const,dG)
c = const.c;
A = const.A;
b = const.b;
m = size(A,1);

% Construct Q matrix
Qvec = exp(2*v);
Q = diag(Qvec);

% Solve for x
% x =  dG\(2*sqrt(mu)*A'*exp(v) - (c + A'*Q*b));
x =  dG\(dG'\(2*sqrt(mu)*A'*exp(v) - (c + A'*Q*b)));
d = ones(m,1) - (1/sqrt(mu))*exp(v).*(A*x + b);
end





