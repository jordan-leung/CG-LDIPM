function [x,output] = cgLDIPM_longstep_inexact_alternative(W,c,Aineq,bineq,v0,opts)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

% Get size variables
m = size(Aineq,1);
n = size(Aineq,2);

% Set options
if isfield(opts,'mu_f')
    mu_f = opts.mu_f;
else
    mu_f = 1e-8;
end
if isfield(opts,'mu_0')
    mu_0 = opts.mu_0;
else
    mu_0 = 1e8;
end
if isfield(opts,'printFlag')
    printFlag = opts.printFlag;
else
    printFlag = 0;
end
if isfield(opts,'maxCGIter')
    maxCGIter = opts.maxCGIter;
else
    maxCGIter = 1000;
end
if isfield(opts,'CGTol')
    CGTol = opts.CGTol;
else
    CGTol = 1e-8;
end

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = Aineq;
const.b = bineq;
const.mu_f = mu_f;
numIter = 1; % number of newton iterations performed




%% * Initializationn procedure

% Unpack shortstep parameters
v = v0;
x = zeros(n,1);
mu = mu_0;
gamma = opts.gamma;
const.gamma = gamma;
const.minEig = min(eig(W));


% Store CG output feedback
maxIter = 1000; % just for initialization
CGIters = zeros(maxIter,2);
CGres = zeros(maxIter,2);
muVec = zeros(maxIter,1);

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)
% Sample point 1
mu2 = mu;
k2 = 1/sqrt(mu2);
[x2,d2Hat,r2,cg2,rlim2] = solveNewtonStep(mu2,v,const,maxCGIter,CGTol,x);

% Sample point 2
mu1 = 100*mu2;
k1 = 1/sqrt(mu1);
[x1,d1Hat,r1,cg1,rlim1] = solveNewtonStep(mu1,v,const,maxCGIter,CGTol,x);
CGIters(numIter,:) = [cg1 cg2];
CGres(numIter,:) = [rlim1 rlim2];

% Solve for muStar
[muStar,dStar,xStar] = muStarSolve(d1Hat,d2Hat,k1,k2,r1,r2,x1,x2,const);

% If we found a muStar (or a feasible point), then use these values
if  muStar < mu
    mu = muStar;
    d = dStar;
    x = xStar;
    startFlag = 1;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'inf'))
    end
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
else
    mu = mu_0; % under the update at the end
    d = d2Hat;
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Initial) \n',mu,norm(d,'inf'))
    end
    
end
muVec(numIter) = mu;


%% * Main iteration loop

while mu > mu_f || norm(d,'inf') > 1
    if numIter >= maxIter % We want at least aa feasible soluton
        exitFlag  =  0;
        break
    end
    

    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)
    % Sample point 1
    mu2 = mu;
    k2 = 1/sqrt(mu2);
    [x2,d2Hat,r2,cg2,rlim2] = solveNewtonStep(mu2,v,const,maxCGIter,CGTol,x);
    CGIters(numIter,2) = cg2;
    CGres(numIter,2) = rlim2;

    % Only perform the search if d2Hat is less than 1
    if norm(d2Hat,'inf') > 1 || mu <= mu_f
        d = d2Hat;
        x = x2;
        cg1 = 0;
        rlim1 = 0;
    else
        % Sample point 2
        mu1 = 100*mu2;
%         mu1 = 1e6;
        k1 = 1/sqrt(mu1);
        [x1,d1Hat,r1,cg1,rlim1] = solveNewtonStep(mu1,v,const,maxCGIter,CGTol,x);
        % Solve for muStar
        [mu,d,x] = muStarSolve(d1Hat,d2Hat,k1,k2,r1,r2,x1,x2,const);
    end
    CGIters(numIter,1) = cg1;
    CGres(numIter,1) = rlim1;

    
    % Make sure that muStar is finite and catch it if not
    if isinf(mu)
        mu = mu2;
        d = d2Hat;
    end
    
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f \n',mu,norm(d,'inf'))
    end
    
    % Update x, v, d
    alpha = min(gamma, 1/(norm(d,'inf')^2));
    v = v + alpha*d;

    % Store variables
    muVec(numIter) = mu;
    numIter = numIter + 1;
end

% Check primal-dual feasibility condition
r1Hat = k1*r1;
r2Hat = k2*r2;
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
t = c1/sqrt(mu) + c0;
r = sqrt(mu)*(t*r1Hat + (1-t)*r2Hat);
p = (Aineq')\r;
lambda = sqrt(mu)*(exp(v) + exp(v).*d) + p;
if min(lambda) > -1e-4
    feasFlag = 1;
else
    feasFlag = 0;

    % Run the post-processing step
    [x,d,r,cg] = solveNewtonStep(mu,v,const,maxCGIter,CGTol,x,1);
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
    CGIters(numIter,1) = CGIters(numIter,1) + cg;
end


% Set output
numIter = numIter - 1;
output.v = v;
output.CGIters = CGIters(1:numIter,:);
output.CGres = CGres(1:numIter,:);
output.muVec = muVec(1:numIter);
output.numIter = numIter;
output.maxIter = maxIter;
output.feasFlag = feasFlag;
output.lambda = lambda;
end



function [x,d,r,numIter,rlim] = solveNewtonStep(mu,v,const,maxIter,tol,x0,exactFlag)
if nargin < 7
    exactFlag = 0;
end

W = const.W;
% invW = const.invW;
c = const.c;
A = const.A;
b = const.b;
m = size(A,1);
gamma = const.gamma;
minEig = const.minEig;

% Define the RHS vector b
Q = diag(exp(2*v));
M = A'*Q*A + W;
expv = exp(v);
f = 2*sqrt(mu)*A'*expv - (c + A'*Q*b);

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.

% Run the first iteration of CG and iniialize iteration variables
x = x0;
r = f - M*x0;

% Calculate iteration constants
z = r;
p = z;
w = M*p;
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
numIter = 1;

% Iterate...
truncCond = 0;
while numIter  < maxIter && res > tol && truncCond ==  0
    zPrev = z;
    z = r;
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = M*p;
    alpha = r'*z/(p'*w);
    
    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);

    % i++
    numIter = numIter + 1;

    % Check truncation criteria
    if ~exactFlag
        s_i = A*x+b;
        sInv_i = 1./s_i;
        barGrad_i = A'*sInv_i;
        sigma = (2/(minEig*mu))*norm(W*x + c -  mu*barGrad_i,2);
        d = ones(m,1) - 1/sqrt(mu)*expv.*s_i;
        dNorm = norm(d,2);
        cond1 = (1-gamma)*dNorm^2;
        if (cond1 > 0 && sigma*res < cond1)
            truncCond = 1;
        end
    end
end
if numIter == 1
    s_i = A*x+b;
    sInv_i = 1./s_i;
    barGrad_i = A'*sInv_i;
    sigma = (2/(minEig*mu))*norm(W*x + c -  mu*barGrad_i,2);
    d = ones(m,1) - 1/sqrt(mu)*expv.*s_i;
    cond1 = (1-gamma)*dNorm^2;
end

% Compute rlim
rlim = cond1/sigma;
end


function  [muStar,d,x] = muStarSolve(d1Hat,d2Hat,k1,k2,r1,r2,x1,x2,const)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax

% % Unpack
% A = const.A;
% b = const.b;
% W = const.W;
% c = const.c;
% minEig = const.minEig;
% gamma = const.gamma;
mu_f = const.mu_f;

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Initialize
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
dinfmax = 1;

% Run through the constraints defined by ||d||_\infty <= 1
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end

% Now, we need to check whether this value of mu is a descent direction.
% If it is not, then we perform bisection
mu = muStar;
t = c1/sqrt(mu) + c0;
d = d0 + (1/sqrt(mu))*d1;
x1Hat = k1*x1;
x2Hat = k2*x2;
x = sqrt(mu)*(t*x1Hat + (1-t)*x2Hat);

end
