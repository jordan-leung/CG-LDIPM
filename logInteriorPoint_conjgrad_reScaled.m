function [x,lambda,s,v,mu,startFlag,numIter,muStar,exitFlag,execTime,CGIters,CGres,warmStartRes,CGerror] = logInteriorPoint_conjgrad_direct(W,c,Aineq,bineq,mu_f,mu_0,v0,maxIter,maxCGIter,CGTol,preCondFlag,printFlag)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

exitFlag =  1;
%  exitFlag = 0 indicates max  iter exceeded

if ~exist('maxIter','var')
    maxIter = Inf;
end

if ~exist('printFlag','var')
    printFlag = 1;
end

% Get size variables
m = size(Aineq,1);
n = size(Aineq,2);

% Store CG output feedback
CGIters = zeros(maxIter,2);
CGres = zeros(maxIter,2);
CGerror = zeros(maxIter,2);
warmStartRes = zeros(maxIter,1);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Initialize mu, v, and z = (x,d)
if exist('mu_0','var') 
    mu = mu_0;
else
    mu = 1e8;
end

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = Aineq;
const.b = bineq;
A = Aineq;


% Compute the diagonal values of G which we use for preconditioning in CG
GDiag = zeros(m,1);
for i = 1:m
    a_i = A(i,:);
    GDiag(i) = a_i*invWTimes(a_i',const);
end
const.GDiag = GDiag;

% Max amount of bisection iterations
numIter = 0; % number of newton iterations performed

% --------------------- FIRST NEWTON ITERATION ---------------------
% If we provide a warm-start
tic
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
v = v0;

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)

% Sample point 1
mu1 = 2;
k1 = 1/sqrt(mu1);

% Sample point 2
mu2 = 1;
k2 = 1/sqrt(mu2);

% Run first Newton system, generate a warm-start d2Hat for the 2nd
[d1Hat,d2Hat,f2,MTilde,cg1,res1,appliedPreCond] = solveNewtonStep(mu1,mu2,v,const,maxCGIter,CGTol,zeros(m,1),preCondFlag);

% Run seconds Newton system starting at warm-start d2Hat
[d2Hat,cg2,res2,resInit] = solveNewtonStep_warmStart(f2,v,const,maxCGIter,CGTol,d2Hat,MTilde,appliedPreCond);
CGIters(numIter+1,:) = [cg1 cg2];
CGres(numIter+1,:) = [res1 res2];
warmStartRes(numIter+1) = resInit;

% % FOR STORING CG ERROR -------------- COMMENT THIS OUT IF TRYING TO RUN IN
% % REAL-TIME!!!
% MTemp = eye(m) + diag(exp(v))*A*const.invW*A'*diag(exp(v));
% b1 = ones(m,1) - 1/sqrt(mu1)*exp(v).*(A*invWTimes(sqrt(mu1)*A'*exp(v) - c,const) + bineq); 
% b2 = ones(m,1) - 1/sqrt(mu2)*exp(v).*(A*invWTimes(sqrt(mu2)*A'*exp(v) - c,const) + bineq); 
% error1 = norm(MTemp\b1 - d1Hat);
% error2 = norm(MTemp\b2 - d2Hat);
% CGerror(numIter+1,:) = [error1 error2];

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'Inf'))
    end
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'Inf')^2));
    v = v + alpha*d;
    numIter = numIter + 1;
else % Otherwise, truly give  up and cold start
    mu = mu_0; % under the update at the end
    d = Inf*dStar;
        v = zeros(size(Aineq,1),1);
        %     v = (log(1e-3) - log(sqrt(mu_0)))*ones(size(Aineq,1),1);
    startFlag = 0;
end

% If we have a pair (mu,d) with d > 1 and we iterate the Newton
% algorithm until we obtain convergence. If we found a muStar from our
% initialization, this loop will be skipped.
if startFlag < 1
    init = 1;
    while norm(d,'Inf') > 1 || init == 1
        if init == 1
            init = 0;
            d = zeros(size(Aineq,1),1);
        end
        % Solve for d
        if numIter >= maxIter % We want at least aa feasible soluton
            exitFlag =  0;
            break
        end
        %         [d,cg,res,CGpcflag] = solveNewtonStep(mu,v,const,zeros(m,1));
        [d,~,~,~,cg,res,CGpcflag] = solveNewtonStep(mu,[],v,const,maxCGIter,CGTol,d,preCondFlag);
        CGIters(numIter+1,:) = [cg cg];
        CGres(numIter+1,:) = [res res];
        
%         % FOR STORING CG ERROR -------------- COMMENT THIS OUT IF TRYING TO RUN IN
%         % REAL-TIME!!!
%         MTemp = eye(m) + diag(exp(v))*ACon*const.invW*ACon'*diag(exp(v));
%         b1 = ones(m,1) - 1/sqrt(mu)*exp(v).*(A*invWTimes(sqrt(mu)*A'*exp(v) - c,const) + bineq);
%         error1 = norm(MTemp\b1 - d);
%         CGerror(numIter+1,:) = [error1 error1];


        % Update v
        alpha = min(1, 1/(norm(d,'Inf')^2));
        v = v + alpha*d;
        numIter = numIter + 1;
        
        % Print statement
        if printFlag
            fprintf('mu = %0.2e, d = %0.4f (Initial Stage) \n',mu,norm(d,'Inf'))
        end
    end
end

% --------------------- MAIN NEWTON ITERATION LOOP ---------------------

% Then, we finally run the main loop which selects muStar
d1Hat = d; % initialize for use in WS the first step
dNorm = 1;
imperfectFlag = 1;

while mu > mu_f || dNorm > 1 || numIter >= maxIter  || imperfectFlag
    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)
    
    % As we approach the optimal solution, switch to tighter settings
    if mu <= 10*mu_f && imperfectFlag
        imperfectFlag = 0;
        maxCGIter = 2*max([n m]);
        CGTol = 1e-10;
    end    
    
    % Run the first Newton system
    [d1Hat,d2Hat,f2,MTilde,cg1,res1,appliedPreCond] = solveNewtonStep(mu1,mu2,v,const,maxCGIter,CGTol,d1Hat,preCondFlag);
    
    % Run the second
    [d2Hat,cg2,res2,resInit] = solveNewtonStep_warmStart(f2,v,const,maxCGIter,CGTol,d2Hat,MTilde,appliedPreCond);
    CGIters(numIter+1,:) = [cg1 cg2];
    CGres(numIter+1,:) = [res1 res2];
    warmStartRes(numIter+1) = resInit;
    
%     % FOR STORING CG ERROR -------------- COMMENT THIS OUT IF TRYING TO RUN IN
%     % REAL-TIME!!!
%     MTemp = eye(m) + diag(exp(v))*A*const.invW*A'*diag(exp(v));
%     b1 = ones(m,1) - 1/sqrt(mu1)*exp(v).*(A*invWTimes(sqrt(mu1)*A'*exp(v) - c,const) + bineq);
%     b2 = ones(m,1) - 1/sqrt(mu2)*exp(v).*(A*invWTimes(sqrt(mu2)*A'*exp(v) - c,const) + bineq);
%     error1 = norm(MTemp\b1 - d1Hat);
%     error2 = norm(MTemp\b2 - d2Hat);
%     CGerror(numIter+1,:) = [error1 error2];

    % Obtain affine representation of d = d0 + k*d1
    c0 = -k2/(k1-k2);
    c1 = 1/(k1-k2);
    d0 = c0*d1Hat + (1-c0)*d2Hat;
    d1 = c1*(d1Hat - d2Hat);
    
    % Solve for muStar using bisection
    [muStar,d] = muStarSolve(d0,d1,1,mu_f);
    
    % Make sure that muStar is finite and catch it if not
    if isinf(muStar)
        d = d0 + 1/sqrt(mu)*d1; 
    else
        mu = muStar;
    end
    
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f \n',mu,norm(d,'Inf'))
    end
    
    % Update x, v, d
    dNorm = norm(d,'Inf'); 
    alpha = min(1, 1/(dNorm^2));
    vPrev = v;
    v = v + alpha*d;
    numIter = numIter + 1;
end

% Solve for primal variable x
x = invWTimes(sqrt(mu)*A'*(exp(vPrev) + exp(vPrev).*d) - c,const);
lambda = sqrt(mu)*exp(v);
s = sqrt(mu)*exp(-v);
execTime = toc;
CGIters = CGIters(1:numIter,:);
CGres = CGres(1:numIter,:);
CGerror = CGerror(1:numIter,:);
warmStartRes = warmStartRes(1:numIter);
end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end


function [d,dNext,fNext,MTilde,numIter,resStar,applyPreCond] = solveNewtonStep(mu,muNext,v,const,maxIter,tol,d0,preCondFlag)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);
GDiag = const.GDiag;

% Define the preconditioner MTilde
MTilde = ones(m,1) + exp(v).*GDiag.*exp(v);

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);
if ~isempty(muNext)
    fNext = ones(m,1) - 1/sqrt(muNext)*exp(v).*(ACon*invWTimes(sqrt(muNext)*ACon'*exp(v) - c,const) + bCon);
else
    fNext = [];
    dNext = [];
end

% First, determine whether or not to apply the diagonal preconditioner. Use
% a criterion than at least 1/4 of the variables have dropped below
% vTresh... This means that many elements of exp(v) will be near zero
vThresh = -2;
vNumThresh = m/4;
negVec = find(v < vThresh);
if preCondFlag == 1
    if length(negVec) > vNumThresh
        applyPreCond = 1;
    else
        applyPreCond = 0;
    end
else
    applyPreCond = 0;
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;
xStar = x; % initialize
resStar = norm(r,2); % initialize

% Calculate iteration constants
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Define/initialize xNext and the associated b vectors
if ~isempty(muNext)
    bBar = fNext - Md0;
    bHat_i = r'*bBar/(resStar^2);
    bBar = bBar - bHat_i*r; % update
    bSum = bHat_i; % initialize
    v_i = alpha*bSum;
    u_i = r;
    xNext = v_i*u_i;
end

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
if res < resStar % Store d as minimal residual solution
    xStar = x;
    resStar = res;
end
numIter = 1;

% Iterate... 
bNorm = norm(b,2);
while numIter  < maxIter && res > tol
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    
    % Update xNext and bNext
    if ~isempty(muNext)
        bHat_i = r'*bBar/(res^2);
        bBar = bBar - bHat_i*r;
        bSum = bSum + bHat_i;
        v_i = alpha*bSum;
        u_i = beta*u_i + r;
        xNext = xNext + v_i*u_i;
    end

    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    if res < resStar
        xStar = x;
        resStar = res;
    end
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = xStar + d0;
if ~isempty(muNext)
    if applyPreCond
        dNext = xNext./MTilde + d0; % note the rescaling for the precond case
    else
        dNext = xNext + d0;
    end
else
    dNext = [];
end
end


function [d,numIter,resStar,resInit] = solveNewtonStep_warmStart(b,v,const,maxIter,tol,d0,MTilde,applyPreCond)
ACon = const.A;
m = size(ACon,1);

% --------------- CONJUGATE GRADIENT ---------------
% Initialize
x = d0;
r = b - MTimes(x,v,const);
d = x;
resStar = norm(r,2);
bNorm = norm(b,2);
resInit = resStar/bNorm;
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);
x = x + alpha*p;
rPrev = r;
r = r - alpha*w;
res = norm(r,2);
if res < resStar % Store d as minimal residual solution
    d = x;
    resStar = res;
end
numIter = 1;


% Iterate... 
while numIter  < maxIter && res > tol
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    if res < resStar
        d = x;
        resStar = res;
    end
    % i++
    numIter = numIter + 1;
end
end



function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end

