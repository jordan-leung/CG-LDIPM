function [x,v,mu,execTime,numIter,CGIters,CGres] = logInteriorPoint_conjgradalt(W,c,Aineq,bineq,mu_f,mu_0,v0,maxIter,maxCGIter,CGTol,muStep,preCondFlag,printFlag)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b
% Get size variabl,es
m = size(Aineq,1);
n = size(Aineq,2);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = Aineq;
const.b = bineq;
A = Aineq;

% Compute the diagonal values of G which we use for preconditioning in CG
GDiag = zeros(m,1);
const.GDiag = GDiag;
for i = 1:m
    a_i = A(i,:);
    GDiag(i) = a_i*invWTimes(a_i',const);
end
const.GDiag = GDiag;

% Max amount of bisection iterations
numIter = 0; % number of newton iterations performed

% Initialize things
CGIters = zeros(maxIter,1);
CGres = zeros(maxIter,1);

% --------------------- MAIN NEWTON ITERATION LOOP ---------------------
tic
% Perform an initial centering procedure
dNorm = 1;
v = v0;
mu = mu_0;
muPrev = mu;
maxCGIter_input = 2*max([n m]);
CGTol_input = 1e-10;
d = zeros(m,1);
while dNorm > 1e-6
    [d,CGIter_i,res] = solveNewtonStep(mu,v,const,d,preCondFlag,maxCGIter_input,CGTol_input);
    dNorm = norm(d,'inf');
    fprintf('mu = %0.2e, d = %0.4f \n',mu,dNorm)
    
    % Update x, v, d
    alpha = min(1, 1/(dNorm^2));
    v = v + alpha*d;
    numIter = numIter + 1;
    
    % Store
    CGIters(numIter) = CGIter_i;
    CGres(numIter) = res;
end



% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
maxCGIter_input = maxCGIter;
CGTol_input = CGTol;
while (muPrev > mu_f || dNorm > 1) && numIter < maxIter
    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)

    % Run the Newton system... If we're on the final iterate, make sure to
    % solve the system to near completition
    if mu < mu_f 
        maxCGIter_input = 2*max([m n]);
        CGTol_input = 1e-10;
    end
    [d,CGIter_i,res] = solveNewtonStep(mu,v,const,d,preCondFlag,maxCGIter_input,CGTol_input);
    
    % Update x, v, d
    if res < 0.5 % only bother to update v if the residual is low... otherwise just repeat a few times
        vPrev = v;
        alpha = min(1, 1/(dNorm^2));
        v = v + alpha*d;
    end
    
    % Increment mu
    dNorm = norm(d,'inf');
    fprintf('mu = %0.2e, d = %0.4f \n',mu,dNorm)
    if dNorm <= 1 - res % ensure dNorm <= 1 - res such that ||d_opt|| <= 1
        muPrev = mu;
        mu = muStep*mu;
    end
    
    % Store
    numIter = numIter + 1;
    CGIters(numIter) = CGIter_i;
    CGres(numIter) = res;
end
execTime = toc;
mu = muPrev;
v = vPrev;
x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
CGIters = CGIters(1:numIter);
CGres = CGres(1:numIter);
end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end


function [d,numIter,resStar] = solveNewtonStep(mu,v,const,d0,preCondFlag,maxIter,tol)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);
GDiag = const.GDiag;

% Define the preconditioner MTilde
MTilde = ones(m,1) + exp(v).*GDiag.*exp(v);

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);

% First, determine whether or not to apply the diagonal preconditioner. Use
% a criterion than at least 1/4 of the variables have dropped below
% vTresh... This means that many elements of exp(v) will be near zero
vThresh = -2;
vNumThresh = m/4;
negVec = find(v < vThresh);
if preCondFlag == 1
    if length(negVec) > vNumThresh
        applyPreCond = 1;
    else
        applyPreCond = 0;
    end
else
    applyPreCond = 0;
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;
xStar = x; % initialize
resStar = norm(r,2); % initialize

% Calculate iteration constants
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
if res < resStar % Store d as minimal residual solution
    xStar = x;
    resStar = res;
end
numIter = 1;

% Iterate... 
while numIter  <= maxIter && res > tol
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    
    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
%     if res < resStar
        xStar = x;
        resStar = res;
%     end
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = xStar + d0;
end
