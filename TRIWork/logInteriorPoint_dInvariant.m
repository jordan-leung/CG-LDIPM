function [x,v,muHist,execTime,numIter,CGIters,CGres,CGerror,dHist,dDiffHist,dInitHist,stepHist] = logInteriorPoint_dInvariant(W,c,Aineq,bineq,mu_f,mu_0,v0,maxIter,maxCGIter,CGTol,preCondFlag,beta,vThresh,vNumThresh,wsFlag)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b
% Get size variabl,es
m = size(Aineq,1);
n = size(Aineq,2);


% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = Aineq;
const.b = bineq;
A = Aineq;

% Compute the diagonal values of G which we use for preconditioning in CG
GDiag = zeros(m,1);
const.GDiag = GDiag;
for i = 1:m
    a_i = A(i,:);
    GDiag(i) = a_i*invWTimes(a_i',const);
end
const.GDiag = GDiag;

% Max amount of bisection iterations
numIter = 0; % number of newton iterations performed

% Initialize things
CGIters = zeros(maxIter,1);
CGres = zeros(maxIter,1);
CGerror = zeros(maxIter,1);
dHist = zeros(maxIter,2); % 1 is 2 norm, 2 is inf norm
dDiffHist = zeros(maxIter,1); 
dInitHist = zeros(maxIter,1); 
muHist = zeros(maxIter,1);
stepHist = zeros(maxIter,2);


% Given parameters (delta,epsilon), deteremine the shortstep parameters (N,k)
const.vThresh = vThresh;
const.vNumThresh = vNumThresh;

tic
% --------------------- INITALiZATION ---------------------
% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)
v = v0;

% Sample point 1
mu1 = 2;
k1 = 1/sqrt(mu1);
[d1Hat,CGIter_i,res] = solveNewtonStep(mu1,v,const,v*0,preCondFlag,maxCGIter,CGTol);
numIter = 1;
CGIters(numIter,:) = [CGIter_i];
CGres(numIter,:) = [res];

% Sample point 2
mu2 = 1;
k2 = 1/sqrt(mu2);
[d2Hat,CGIter_i,res] = solveNewtonStep(mu2,v,const,d1Hat,preCondFlag,maxCGIter,CGTol);
numIter = 2;
CGIters(numIter,:) = [CGIter_i];
CGres(numIter,:) = [res];

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);


% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'Inf'))
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'Inf')^2));
    v = v + alpha*d;
else % Otherwise, truly give  up and cold start
    dNorm = 10000;
    dNorm_inf = 1000;
    mu = mu_0;
    d = zeros(m,1);
    while dNorm_inf > beta
        if wsFlag
            dInit = d;
        else
            dInit = d*0;
        end
        [d,CGIter_i,res] = solveNewtonStep(mu,v,const,dInit,preCondFlag,maxCGIter,CGTol);
        dNorm_inf = norm(d,'inf');
        fprintf('mu = %0.2e, d = %0.4f (Centering) \n',mu,dNorm_inf)
        
        % For calculating error
        MTemp = eye(m) + diag(exp(v))*A*invW*A'*diag(exp(v));
        f = ones(m,1) - 1/sqrt(mu)*exp(v).*(A*invWTimes(sqrt(mu)*A'*exp(v) - c,const) + bineq);
        dOpt = MTemp\f;
        e_i = norm(d - dOpt,2);
        
        % Update x, v, d
        alpha = min(1, 1/(dNorm_inf^2));
        v = v + alpha*d;
        numIter = numIter + 1;
        
        % Store
        dNorm = norm(d,2);
        CGIters(numIter) = CGIter_i;
        CGres(numIter) = res;
        CGerror(numIter) = e_i;
        dHist(numIter,:) = [dNorm dNorm_inf];
        dDiffHist(numIter) = Inf;
        dInitHist(numIter) = norm(dInit - dOpt,2);
        muHist(numIter) = mu;
        stepHist(numIter,:) = [1 0];
    end
end


% --------------------- MAIN NEWTON ITERATION LOOP ---------------------
dPrev = d;
% Determine first mu by doing the thing
g_int = (A*invW*c - bineq);
        Delta = 0;
while mu > mu_f
    % Check if there's a sufficiently large gap, if so then update mu,
    % if not then keep mu fixed so we can increase the gap
    dNorm = norm(d,2);
    dNorm_inf = norm(d,'inf');
    
    % First check if mu is the initial value (bc then we use no
    % acceleration term)
    if mu < mu_0
        b_scaling = 3;
%         rho = beta - dNorm;
        rho = beta - dNorm_inf;
        Delta = max([0, Delta + rho/b_scaling]);
    end
    
    g = exp(v).*g_int;
%     c1 = max([1, ( sqrt(mu)*(beta - dNorm)/norm(g,2) + 1)^2]);
    c1 = max([1, ( sqrt(mu)*(beta - dNorm_inf)/norm(g,2) + 1)^2]);
    c2 = Delta;
    gamma = 1/(c1+c2);
    mu = gamma*mu;

    % Run the Newton system.
    if wsFlag
        dInit = d;
    else
        dInit = d*0;
    end
    [d,CGIter_i,res] = solveNewtonStep(mu,v,const,dInit,preCondFlag,maxCGIter,CGTol);
    
    % For calculating error
    MTemp = eye(m) + diag(exp(v))*A*invW*A'*diag(exp(v));
    f = ones(m,1) - 1/sqrt(mu)*exp(v).*(A*invWTimes(sqrt(mu)*A'*exp(v) - c,const) + bineq);
    dOpt = MTemp\f;
    e_i = norm(d - dOpt,2);
    
    % Update x, v, d
    vPrev = v;
    dNorm_inf = norm(d,'inf');
    alpha = min(1, 1/(dNorm_inf^2));
    v = v + alpha*d;
    fprintf('mu = %0.2e, d = %0.4f, Delta = %0.4f \n',mu,dNorm_inf,Delta)
    
    % Store
    numIter = numIter + 1;
    CGIters(numIter) = CGIter_i;
    CGres(numIter) = res;
    CGerror(numIter) = e_i;
    dHist(numIter,:) = [dNorm dNorm_inf];
    dDiffHist(numIter) = norm(d - dPrev,2);
    dInitHist(numIter) = norm(dInit - dOpt,2);
    muHist(numIter) = mu;
    stepHist(numIter,:) = [c1 c2];
    dPrev = d;
end
% --------------------- FINAL CENTERING LOOP ---------------------
dPrev = d;
% Determine first mu by doing the thing
while dNorm_inf > 1
    % Check if there's a sufficiently large gap, if so then update mu,
    % if not then keep mu fixed so we can increase the gap
    % Run the Newton system.
    if wsFlag
        dInit = d;
    else
        dInit = d*0;
    end
    [d,CGIter_i,res] = solveNewtonStep(mu,v,const,dInit,preCondFlag,maxCGIter,CGTol);
    
    % For calculating error
    MTemp = eye(m) + diag(exp(v))*A*invW*A'*diag(exp(v));
    f = ones(m,1) - 1/sqrt(mu)*exp(v).*(A*invWTimes(sqrt(mu)*A'*exp(v) - c,const) + bineq);
    dOpt = MTemp\f;
    e_i = norm(d - dOpt,2);
    
    % Update x, v, d
    vPrev = v;
    dNorm_inf = norm(d,'inf');
    alpha = min(1, 1/(dNorm_inf^2));
    v = v + alpha*d;
    dNorm = norm(d,2);
    fprintf('mu = %0.2e, d = %0.4f, Delta = %0.4f \n',mu,dNorm_inf,Delta)
    
    % Store
    numIter = numIter + 1;
    CGIters(numIter) = CGIter_i;
    CGres(numIter) = res;
    CGerror(numIter) = e_i;
    dHist(numIter,:) = [dNorm dNorm_inf];
    dDiffHist(numIter) = norm(d - dPrev,2);
    dInitHist(numIter) = norm(dInit - dOpt,2);
    muHist(numIter) = mu;
    stepHist(numIter,:) = [1 0];
    dPrev = d;
end
execTime = toc;
v = vPrev;
x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
CGIters = CGIters(1:numIter);
CGres = CGres(1:numIter);
CGerror = CGerror(1:numIter);
dHist = dHist(1:numIter,:);
dDiffHist = dDiffHist(1:numIter);
dInitHist = dInitHist(1:numIter);
muHist = muHist(1:numIter);
stepHist = stepHist(1:numIter,:);
end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end


function [d,numIter,res] = solveNewtonStep(mu,v,const,d0,preCondFlag,maxIter,tol)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);
GDiag = const.GDiag;

% Define the preconditioner MTilde
MTilde = ones(m,1) + exp(v).*GDiag.*exp(v);

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);

% First, determine whether or not to apply the diagonal preconditioner. Use
% a criterion than at least 1/4 of the variables have dropped below
% vTresh... This means that many elements of exp(v) will be near zero
vThresh = const.vThresh;
vNumThresh = const.vNumThresh;
negVec = find(v < vThresh);
if preCondFlag == 1
    if length(negVec) > vNumThresh
        applyPreCond = 1;
    else
        applyPreCond = 0;
    end
else
    applyPreCond = 0;
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;

% Calculate iteration constants
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
numIter = 1;

% Iterate... 
dNorm = norm(x + d0);
while numIter  <= maxIter && res > tol 
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    
    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);

    % Update the dNorm
    dNorm = norm(x+d0);
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = x + d0;
end



function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = min([mu_f 1e-10]);
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end