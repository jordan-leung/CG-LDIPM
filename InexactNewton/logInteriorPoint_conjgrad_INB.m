function [x,lambda,s,v,mu,startFlag,numIter,muStar,exitFlag,execTime,CGIters,CGres] = logInteriorPoint_conjgrad_INB(W,c,A,b,mu_f,mu_0,v0,maxIter,maxCGIter,CGTol,printFlag)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

exitFlag =  1; %  exitFlag = 0 indicates max iter exceeded

% Get size variables
m = size(A,1);
n = size(A,2);

% Store CG output feedback
CGIters = zeros(maxIter,1);
CGres = zeros(maxIter,1);
x = zeros(n,1);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
A = - A;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = A;
const.b = b;
numIter = 0; % number of newton iterations performed

% Inexact CG parameters
eta = 0.1; % choose eta \in (0,1)
theta = 0.9; % choose theta \in (0,1)
tConst = 0.5; % choose tConst \in (0,1)
const.eta = eta;
const.theta = theta;

% --------------------- FIRST NEWTON ITERATION ---------------------
% If we provide a warm-start
tic
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
v = v0;

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)

% Sample point 1
mu1 = 2;
k1 = 1/sqrt(mu1);

% Sample point 2
mu2 = 1;
k2 = 1/sqrt(mu2);

% Run first Newton system, generate a warm-start d2Hat for the 2nd
[d1Hat,cg1,res1] = solveNewtonStep(mu1,x,v,const,maxCGIter,CGTol,zeros(m,1),1);

% Run seconds Newton system starting at warm-start d2Hat
[d2Hat,cg2,res2] = solveNewtonStep(mu1,x,v,const,maxCGIter,CGTol,d1Hat,1);
CGIters(numIter+1) = cg1+cg2;
CGres(numIter+1) = max([res1 res2]);

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'Inf'))
    end
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'Inf')^2));
    v = v + alpha*d;
    x = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*alpha*d) - c,const);
    numIter = numIter + 1;
else % Otherwise, truly give  up and cold start
    mu = mu_0; % under the update at the end
    d = Inf*dStar;
    v = zeros(size(A,1),1);
    startFlag = 0;
    numIter = numIter + 1;
end


% --------------------- MAIN NEWTON ITERATION LOOP ---------------------

% Then, we finally run the main loop which selects muStar
mu_inc = 0.99;
while mu > mu_f && numIter < maxIter  
    if isinf(d(1))
        % Execute an exact Newton step and use the alpha step-size
        [d,cg,res] = solveNewtonStep(mu,x,v,const,maxCGIter,CGTol,zeros(m,1),1);
        dNorm = norm(d,'inf')
        alpha = min(1, 1/(dNorm^2));
        v = v + alpha*d;
        x = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c,const);
        FPlus = NaN;
    else
        [d,cg,res,res_scaled,Fval] = solveNewtonStep(mu,x,v,const,maxCGIter,CGTol,d,0);
        
        % Run inner-loop backtracking search
        dx_k = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c,const) - x;
        dv_k = d;
        eta_k = eta;
        FPlus = norm(F_eval(x+dx_k,v+dv_k,mu,const),'inf');
        FNorm = norm(Fval,'inf');
        while FPlus > (1 - tConst*(1-eta_k))*FNorm
            dx_k = theta*dx_k;
            dv_k = theta*dv_k;
            eta_k = 1-theta*(1-eta_k);
            FPlus = norm(F_eval(x+dx_k,v+dv_k,mu,const),'inf');
        end
        x = x + dx_k;
        v = v + dv_k;
    end
    
    % Print
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f, F = %0.2e \n',mu,norm(d,'Inf'),FPlus)
    end
    
    dNorm = norm(d,'inf');
    if dNorm < 1
        % Increment mu and
        mu = mu_inc*mu;
    end
    
    % Store
    CGIters(numIter+1) = cg;
    CGres(numIter+1) = res;
    numIter = numIter + 1;
end

% Solve for primal variable x
lambda = sqrt(mu)*exp(v);
s = sqrt(mu)*exp(-v);
execTime = toc;
CGIters = CGIters(1:numIter,:);
CGres = CGres(1:numIter,:);
end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end

% Function to evaluate F(x_k)
function F = F_eval(x,v,mu,const)
% Returns F(x_k)
W = const.W;
c = const.c;
A = const.A;
b = const.b;

F = [W*x - sqrt(mu)*A'*exp(v) + c;...
     A*x - sqrt(mu)*exp(-v) + b];
end


function [d,numIter,res,res_scaled,Fval] = solveNewtonStep(mu,x,v,const,maxIter,tol,d0,exactFlag)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);

% Unpack inexact Newton parameters
eta = const.eta;

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);

% Define the residual bound
if ~exactFlag
    Fval = F_eval(x,v,mu,const);
    RHS_bound = (eta/sqrt(mu))*norm(Fval,'inf');
else
    Fval = 0;
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;

% Calculate iteration constants
z = r;
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
numIter = 1;

% Calculate residual and the scaled residual
res = norm(r,2);
if ~exactFlag
   res_scaled = norm(exp(-v).*r,'inf');
else
    res_scaled = 2; % include just to disregard this condition
    RHS_bound = 1;
end

% Iterate... 
while numIter  < maxIter && res > tol && res_scaled > RHS_bound
    % Perform CG iterations
    zPrev = z;
    z = r;
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);

    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    
    % Update the scaled residual
    if ~exactFlag
        res_scaled = norm(exp(-v).*r,'inf');
    end
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = x + d0;
end



function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = min([mu_f 1e-10]);
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end

