function [x,output] = logInteriorPoint_conjgrad_INB(W,c,A,b,v0,opts)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b

% Set options
if isfield(opts,'mu_f')
    mu_f = opts.mu_f;
else
    mu_f = 1e-8;
end
if isfield(opts,'mu_0')
    mu_0 = opts.mu_0;
else
    mu_0 = 1e8;
end
if isfield(opts,'maxIter')
    maxIter = opts.maxIter;
else
    maxIter = 150;
end
if isfield(opts,'printFlag')
    printFlag = opts.printFlag;
else
    printFlag = 0;
end
if isfield(opts,'maxCGIter')
    maxCGIter = opts.maxCGIter;
else
    maxCGIter = 1000;
end
if isfield(opts,'CGTol')
    CGTol = opts.CGTol;
else
    CGTol = 1e-8;
end
if isfield(opts,'FNormLimit')
    FNormLimit = opts.FNormLimit;
else
    FNormLimit = 1e-2;
end

% Get size variables
m = size(A,1);
n = size(A,2);

% Store CG output feedback
CGIters = zeros(maxIter,1);
CGres = zeros(maxIter,1);
muVec = zeros(maxIter,1);
FVec = zeros(maxIter,1);
feasVec = zeros(maxIter,1);
x = zeros(n,1);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
A = -A;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = A;
const.b = b;
numIter = 0; % number of newton iterations performed

% Inexact CG parameters
theta = 0.9; % choose theta \in (0,1)
tConst = 0.5; % choose tConst \in (0,1)
const.theta = theta;

% --------------------- FIRST NEWTON ITERATION ---------------------
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0
v = v0;

% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)

% Sample point 1
mu1 = 2;
k1 = 1/sqrt(mu1);

% Sample point 2
mu2 = 1;
k2 = 1/sqrt(mu2);

% Run first Newton system, generate a warm-start d2Hat for the 2nd
[d1Hat,cg1,res1] = solveNewtonStep(mu1,v,const,maxCGIter,CGTol,zeros(m,1),1);

% Run seconds Newton system starting at warm-start d2Hat
[d2Hat,cg2,res2] = solveNewtonStep(mu2,v,const,maxCGIter,CGTol,d1Hat,1);
CGIters(numIter+1) = cg1+cg2;
CGres(numIter+1) = max([res1 res2]);

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f (Warmstart) \n',mu,norm(d,'Inf'))
    end
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'Inf')^2));
    v = v + alpha*d;
    x = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*alpha.*d) - c,const);
    numIter = numIter + 1;
else % Otherwise, truly give  up and cold start
    mu = mu_0; % under the update at the end
    d = zeros(m,1);
    v = zeros(size(A,1),1);
    startFlag = 0;
    numIter = numIter + 1;
end
muVec(numIter) = mu;

% --------------------- MAIN NEWTON ITERATION LOOP ---------------------

% Run a subroutine of exact Newton steps to make sure we get into within
% the FNorm region
F = F_eval(x,v,mu,const);
while norm(F,'inf') > FNormLimit && numIter < maxIter
    % Compute newton step
    [d,cg,res] = solveNewtonStep(mu,v,const,maxCGIter,CGTol,d,1);
    alpha = min(1, 1/(norm(d,'Inf')^2));
    v = v + alpha*d;
    x = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*alpha.*d) - c,const);
    
    % Update
    CGIters(numIter+1) = cg;
    CGres(numIter+1) = res;
    muVec(numIter+1) = mu;
    numIter = numIter + 1;    
    F = F_eval(x,v,mu,const);
end


% Then, we finally run the main loop which selects muStar
etaInitFlag = 1;
muPrev = mu;
notFeasible = 1;
numIter = numIter - 1;
while (muPrev > mu_f && numIter < maxIter) || notFeasible    
    % Solve inexact Newton
    if etaInitFlag
        eta = 0.01; % inital eta
        etaInitFlag = 0;
        
        % Evaluate for next pass
        F = F_eval(x,v,mu,const);
        FPrime = FPrime_eval(v,mu,const);
    else
        % Evaluate F(x_k) and F'(x_k)
        F = F_eval(x,v,mu,const);
        FPrime = FPrime_eval(v,mu,const);
        if mu > mu_f
            eta = norm(F - FPrev - FPrimePrev*sPrev,'inf')/norm(FPrev,'inf');
        else
            eta = 1e-4;
        end
    end

    % Execute inexact newton to tolerace epsilon
    [d,cg,res,res_scaled] = solveNewtonStep(mu,v,const,maxCGIter,CGTol,d,0,eta,F);
    
    % Run inner-loop backtracking search
    dx_k = invWTimes(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c,const) - x;
    dv_k = d;
    eta_k = eta;
    FPlus = norm(F_eval(x+dx_k,v+dv_k,mu,const),'inf');
    FNorm = norm(F,'inf');
    muPrev = mu;
    
    % Track how many backtrack searches we do. If we're doing a tonne, then
    % relax the tolerance
    toltol = 0;
    numBack = 1;
    while FPlus > (1 - tConst*(1-eta_k))*FNorm + toltol*FNorm
        dx_k = theta*dx_k;
        dv_k = theta*dv_k;
        eta_k = 1-theta*(1-eta_k);
        FPlus = norm(F_eval(x+dx_k,v+dv_k,mu,const),'inf');
        if numBack > 100
            toltol  = 1e-4;
        end
        numBack = numBack+1;
    end
    x = x + dx_k;
    v = v + dv_k;
    FPrev = F;
    FPrimePrev = FPrime;
    sPrev = [dx_k; dv_k];
    
    % Print
    if printFlag
        fprintf('mu = %0.2e, d = %0.4f, F = %0.2e, F+ = %0.2e, Feas: %0.0f \n',mu,norm(d,'Inf'),FNorm,FPlus,~notFeasible)
    end
    
    % Check feasibility
    minSlack = min(A*x + b);
    if minSlack < -1e-6 
        notFeasible = 1;
    else
        notFeasible = 0;
    end        
    
    % Incremement mu if our F(x+) value is less than the threshold (and
    % mu > mu_f)
    if FPlus < FNormLimit && mu > mu_f
        muStar = muStarSolve_FNorm(x,v,const,FNormLimit,mu_f);
        if muStar < mu
            mu = muStar;
        end
    end
    FVec(numIter+1) = FNorm;
    feasVec(numIter+1) = ~notFeasible;
    
    % Store
    muVec(numIter+1) = mu;
    CGIters(numIter+1) = cg;
    CGres(numIter+1) = res;
    numIter = numIter + 1;
end
muVec(numIter) = mu;
feasVec(numIter) = 1;

% Solve for primal variable x
output.lambda = sqrt(mu)*exp(v);
output.s = sqrt(mu)*exp(-v);
output.v = v;

% Set outputs
output.startFlag = startFlag;
output.numIter = numIter;
output.muStar = muStar;
output.muVec = muVec(1:numIter);
output.CGIters = CGIters(1:numIter,:);
output.CGres = CGres(1:numIter,:);
output.FVec = FVec(1:numIter-1);
output.feasVec = feasVec(1:numIter);

end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end

% Function to evaluate F(x_k)
function F = F_eval(x,v,mu,const)
% Returns F(x_k)
W = const.W;
c = const.c;
A = const.A;
b = const.b;

F = [W*x - sqrt(mu)*A'*exp(v) + c;...
    A*x - sqrt(mu)*exp(-v) + b];
end

% Function to evaluate F'(x_k)
function FPrime = FPrime_eval(v,mu,const)
% Returns F(x_k)
W = const.W;
A = const.A;

FPrime = [W, - sqrt(mu)*A'*diag(exp(v));...
    A, sqrt(mu)*diag(exp(-v))];
end


function [d,numIter,res,res_scaled] = solveNewtonStep(mu,v,const,maxIter,tol,d0,exactFlag,eta,F)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);

% Define the residual bound
if ~exactFlag
    RHS_bound = (eta/sqrt(mu))*norm(F,'inf');
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;

% Calculate iteration constants
z = r;
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Update x and r
x = x + alpha*p;
rPrev = r;
r = r - alpha*w; % r1
numIter = 1;

% Calculate residual and the scaled residual
res = norm(r,2);
if ~exactFlag
    res_scaled = norm(exp(-v).*r,'inf');
else
    res_scaled = 2; % include just to disregard this condition
    RHS_bound = 1;
end

% Iterate...
while numIter  < maxIter && res > tol && res_scaled > RHS_bound
    % Perform CG iterations
    zPrev = z;
    z = r;
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    
    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    
    % Update the scaled residual
    if ~exactFlag
        res_scaled = norm(exp(-v).*r,'inf');
    end
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = x + d0;
end



function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end



function  [muStar] = muStarSolve_FNorm(x,v,const,FMax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
A = const.A;

d0 = [const.W*x + const.c; A*x +  const.b];
d1 = -[A'*exp(v) ; exp(-v)];

m = length(d0);
for i  = 1:m
    upper_bound_i = (FMax - d0(i)) / d1(i);
    lower_bound_i = (-FMax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = Inf;
        break
    else
        kStar = lower_bound; % note k = sqrt(deltaMu), so we want the largest k
    end
end
muStar = kStar^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
end
