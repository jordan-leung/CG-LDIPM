function [x,xError_vec,execTime,numIter] = logInteriorPoint_conjgrad_box(W,c,xmin,xmax,mu_f,mu_0,v0,maxIter,maxCGIter,preCondFlag,xStar,xTol)
% min 0.5*x'*W*x + c'*x   subject to:  A*x <= b
% Get size variables
[Aineq,bineq] = minmaxMatrices(xmin,xmax);
m = size(Aineq,1);
n = size(Aineq,2);

% First, change variables to Ax + b >= 0... This is just for uniformity
% with quadprog's inputs.
Aineq = - Aineq;

% Pack
invW = inv(W);
const.W = W;
const.invW = invW;
const.c = c;
const.A = Aineq;
const.b = bineq;
const.maxCGIter = maxCGIter;
const.CGTol = 1e-12;
GDiag = zeros(m,1);
const.GDiag = GDiag;
A = Aineq;

% Compute the diagonal values of G which we use for preconditioning in CG
for i = 1:m
    a_i = A(i,:);
    GDiag(i) = a_i*invWTimes(a_i',const);
end
const.GDiag = GDiag;

% Max amount of bisection iterations
numIter = 0; % number of newton iterations performed

% --------------------- FIRST NEWTON ITERATION ---------------------
% If we provide a warm-start
tic
% On initialization pass we first check if we can find a muStar value
% within N iterations of biscection... If not, then we just initialize with
% mu0

% First, solve for the unconstrained solution and project onto solution
xStar_unc = -invWTimes(c,const);
xProj = xStar_unc;
for i = 1:n
   if xProj(i) >  xmax(i)
       xProj(i) = xmax(i);
   elseif xProj(i) < xmin(i)
       xProj(i) = xmin(i);
   end
end

% Calculate slack
s_init = Aineq*xProj - bineq;
for i = 1:m
    if s_init(i) < 1e-6
        s_init(i) = 1e-6;
    end
end
v = -log(s_init);
    


% First, we sample two points of (mu,d) and solve the linear system
% generated by d = d0 + k*d1, where k = 1/sqrt(mu)

% Sample point 1
mu1 = 2;
k1 = 1/sqrt(mu1);

% Sample point 2
mu2 = 1;
k2 = 1/sqrt(mu2);

% Run first Newton system, generate a warm-start d2Hat for the 2nd
[d1Hat,d2Hat,f2,MTilde,~,~,appliedPreCond] = solveNewtonStep(mu1,mu2,v,const,zeros(m,1),preCondFlag);

% Run seconds Newton system starting at warm-start d2Hat
d2Hat = solveNewtonStep_warmStart(f2,v,const,d2Hat,MTilde,appliedPreCond);

% Obtain affine representation of d = d0 + k*d1
c0 = -k2/(k1-k2);
c1 = 1/(k1-k2);
d0 = c0*d1Hat + (1-c0)*d2Hat;
d1 = c1*(d1Hat - d2Hat);

% Solve for muStar
[muStar,dStar] = muStarSolve(d0,d1,1,mu_f);

% If we found a muStar (or a feasible point), then use these values
if ~isinf(muStar)
    mu = muStar;
    d = dStar;
    startFlag = 1;
    
    % Update v - this updates regardless of whether or not we find a
    % feasible mu... Either just iterates off mu0, or to muStar
    alpha = min(1, 1/(norm(d,'inf')^2));
    v = v + alpha*d;
    numIter = numIter + 1;
else % Otherwise, truly give  up and cold start
    mu = mu_0; % under the update at the end
    d = Inf*dStar;
    v = zeros(size(Aineq,1),1);
    startFlag = 0;
end

% If we have a pair (mu,d) with d > 1 and we iterate the Newton
% algorithm until we obtain convergence. If we found a muStar from our
% initialization, this loop will be skipped.
xError_vec = zeros(maxIter,1);
x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
xError = norm(x - xStar);
xError_vec(1) = xError;
if startFlag < 1
    init = 1;
    while norm(d,'inf') > 1 || init == 1
        if init == 1
            init = 0;
            d = zeros(size(Aineq,1),1);
        end
        % Solve for d
        if numIter >= maxIter % We want at least aa feasible soluton
            exitFlag =  0;
            break
        end
        %         [d,cg,res,CGpcflag] = solveNewtonStep(mu,v,const,zeros(m,1));
        d = solveNewtonStep(mu,[],v,const,d,preCondFlag);
        x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
        xError = norm(x - xStar);
        xError_vec(numIter+1) = xError;

        % Update v
        alpha = min(1, 1/(norm(d,'inf')^2));
        v = v + alpha*d;
        numIter = numIter + 1;
    end
end

% --------------------- MAIN NEWTON ITERATION LOOP ---------------------

% Then, we finally run the main loop which selects muStar
d1Hat = d; % initialize for use in WS the first step
dNorm = 1;
while (xError > xTol || dNorm > 1) && numIter < maxIter
    % First, we sample two points of (mu,d) and solve the linear system
    % generated by d = d0 + k*d1, where k = 1/sqrt(mu)

    % Run the first Newton system
    [d1Hat,d2Hat,f2,MTilde,~,~,appliedPreCond] = solveNewtonStep(mu1,mu2,v,const,d1Hat,preCondFlag);
    
    % Run the second
    d2Hat = solveNewtonStep_warmStart(f2,v,const,d2Hat,MTilde,appliedPreCond);
    
    % Obtain affine representation of d = d0 + k*d1
    c0 = -k2/(k1-k2);
    c1 = 1/(k1-k2);
    d0 = c0*d1Hat + (1-c0)*d2Hat;
    d1 = c1*(d1Hat - d2Hat);
    
    % Solve for muStar using bisection
    [muStar,d] = muStarSolve(d0,d1,1,mu_f);
    
    % Make sure that muStar is finite and catch it if not
    if isinf(muStar)
        d = d0 + 1/sqrt(mu)*d1; % mu is unchanged, change d
    else
        mu = muStar; % mu is changed, we use the calculated d
    end
    
    % Get xError
    x = invW*(sqrt(mu)*A'*(exp(v) + exp(v).*d) - c);
    xError = norm(x - xStar);
    xError_vec(numIter+1) = xError;
    
    % Update x, v, d
    dNorm = norm(d,'inf');
    alpha = min(1, 1/(dNorm^2));
    v = v + alpha*d;
    numIter = numIter + 1;
    
end
execTime = toc;
xError_vec = xError_vec(1:numIter);
end


% This is a placeholder function for when we eventually use Riccatti
function zOut = invWTimes(zIn,const)
% Returns zOut = invW*zIn
zOut = const.invW*zIn;
end

% Function to evaluate M(v)*x
function zOut = MTimes(zIn,v,const)
% Returns zOut = M(v)*zIn
A = const.A;
D = exp(v);
zOut = zIn + D.*(A*( invWTimes(A'*(D.*zIn),const)));
end


function [d,dNext,fNext,MTilde,numIter,resStar,applyPreCond] = solveNewtonStep(mu,muNext,v,const,d0,preCondFlag)
% W = const.W;
% invW = const.invW;
c = const.c;
ACon = const.A;
bCon = const.b;
m = size(ACon,1);
maxIter = min([const.maxCGIter, m]);
GDiag = const.GDiag;

% Define the preconditioner MTilde
MTilde = ones(m,1) + exp(v).*GDiag.*exp(v);

% Define the RHS vector b
f = ones(m,1) - 1/sqrt(mu)*exp(v).*(ACon*invWTimes(sqrt(mu)*ACon'*exp(v) - c,const) + bCon);
if ~isempty(muNext)
    fNext = ones(m,1) - 1/sqrt(muNext)*exp(v).*(ACon*invWTimes(sqrt(muNext)*ACon'*exp(v) - c,const) + bCon);
end

% First, determine whether or not to apply the diagonal preconditioner. Use
% a criterion than at least 1/4 of the variables have dropped below
% vTresh... This means that many elements of exp(v) will be near zero
vThresh = -4;
vNumThresh = m/4;
negVec = find(v < vThresh);
if preCondFlag == 1
    if length(negVec) > vNumThresh
        applyPreCond = 1;
    else
        applyPreCond = 0;
    end
else
    applyPreCond = 0;
end

% --------------- CONJUGATE GRADIENT ---------------
% Initialize and redefine the problem such that x0 = 0.
x = zeros(size(d0,1),1); % correct at the end by d = x + d0
Md0 = MTimes(d0,v,const);
b = f - Md0;

% Run the first iteration of CG and iniialize iteration variables
r = b;
xStar = x; % initialize
resStar = norm(r,2); % initialize

% Calculate iteration constants
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);

% Define/initialize xNext and the associated b vectors
if ~isempty(muNext)
    bBar = fNext - Md0;
    bHat_i = r'*bBar/(resStar^2);
    bBar = bBar - bHat_i*r; % update
    bSum = bHat_i; % initialize
    v_i = alpha*bSum;
    u_i = r;
    xNext = v_i*u_i;
end

% Update x and r
x = x + alpha*p; 
rPrev = r;
r = r - alpha*w; % r1
res = norm(r,2);
if res < resStar % Store d as minimal residual solution
    xStar = x;
    resStar = res;
end
numIter = 1;

% Iterate... 
tol = const.CGTol;
bNorm = norm(b,2);
while numIter  <= maxIter && res/bNorm > tol
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    
    % Update xNext and bNext
    if ~isempty(muNext)
        bHat_i = r'*bBar/(res^2);
        bBar = bBar - bHat_i*r;
        bSum = bSum + bHat_i;
        v_i = alpha*bSum;
        u_i = beta*u_i + r;
        xNext = xNext + v_i*u_i;
    end

    % Update x
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    if res < resStar
        xStar = x;
        resStar = res;
    end
    
    % i++
    numIter = numIter + 1;
end

% Undo the change of variables
d = xStar + d0;
if ~isempty(muNext)
    if applyPreCond
        dNext = xNext./MTilde + d0; % note the rescaling for the precond case
    else
        dNext = xNext + d0;
    end
else
    dNext = [];
end
end


function [d,numIter,resStar,resInit] = solveNewtonStep_warmStart(b,v,const,d0,MTilde,applyPreCond)
ACon = const.A;
m = size(ACon,1);
maxIter = min([const.maxCGIter, m]);

% --------------- CONJUGATE GRADIENT ---------------
% Initialize
x = d0;
r = b - MTimes(x,v,const);
d = x;
resStar = norm(r,2);
bNorm = norm(b,2);
resInit = resStar/bNorm;
if applyPreCond
    z = r./MTilde; % preconditioner step
else
    z = r;
end
p = z;
w = MTimes(p,v,const);
alpha = r'*z/(p'*w);
x = x + alpha*p;
rPrev = r;
r = r - alpha*w;
res = norm(r,2);
if res < resStar % Store d as minimal residual solution
    d = x;
    resStar = res;
end
numIter = 1;


% Iterate... 
tol = const.CGTol;
while numIter  < maxIter && res/bNorm > tol
    zPrev = z;
    if applyPreCond
        z = r./MTilde;
    else
        z = r;
    end
    beta = r'*z/(rPrev'*zPrev);
    p = z + beta*p;
    w = MTimes(p,v,const);
    alpha = r'*z/(p'*w);
    x = x + alpha*p;
    rPrev = r;
    r = r - alpha*w;
    res = norm(r,2);
    if res < resStar
        d = x;
        resStar = res;
    end
    % i++
    numIter = numIter + 1;
end
end



function  [muStar,d] = muStarSolve(d0,d1,dinfmax,mu_f)
% // Returns the largest k satisfying | d0 + k * d1 |_{infty} \le dinfmax
upper_bound = 1e14;
lower_bound =  0;
m = length(d0);
for i  = 1:m
    upper_bound_i = (dinfmax - d0(i)) / d1(i);
    lower_bound_i = (-dinfmax - d0(i)) / d1(i);
    
    % Neither is either lower or upper necessarily, so just reorder
    % according to whichever is larger
    if (lower_bound_i > upper_bound_i)
        temp =  upper_bound_i;
        upper_bound_i = lower_bound_i;
        lower_bound_i = temp;
    end
    
    % Check whether or not this is larger/small than the previous upper and
    % lower bounds
    if upper_bound_i < upper_bound
        upper_bound = upper_bound_i;
    end
    if lower_bound_i > lower_bound
        lower_bound = lower_bound_i;
    end
    
    % Finally, check if lower_bound > upper_bound, indicating that  the
    % solution is infeasible
    if lower_bound > upper_bound
        kStar = 0;
        break
    else
        kStar = upper_bound; % note k = 1/sqrt(mu), so we want the largest k
    end
end
muStar = (1/kStar)^2; % returns muStar = Inf if infeasible
if muStar < mu_f % make sure muStar isn't too small or too large for numerical reasons
    muStar = mu_f;
elseif muStar > 1e10
    muStar = Inf;
end
d = d0 + (1/sqrt(muStar))*d1;
end
